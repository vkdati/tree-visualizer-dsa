<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Red-Black Tree Visualization</title>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>

  <h1>Red-Black Tree Visualization</h1>

  <!-- Input field to add a value to the tree -->
  <input type="text" id="val" placeholder="Enter value" />
  <button onclick="addNode()">Add Node</button>

  <!-- Paragraph to display the in-order traversal of the tree -->
  <p id="out">In-order: </p>

  <!-- Canvas element to draw the Red-Black tree -->
  <canvas id="rbCanvas" width="800" height="600"></canvas>

  <script>
    // Node class to represent each node in the Red-Black Tree
    class Node {
      constructor(data) {
        this.data = data;
        this.color = "RED";  // New nodes are always red when inserted
        this.left = null;
        this.right = null;
        this.parent = null;
      }
    }

    // Red-Black Tree class
    class Tree {
      constructor() {
        this.root = null;  // Initialize root of the Red-Black Tree as null
      }

      // Left rotation (similar to AVL tree rotation)
      rotateL(x) {
        let y = x.right;
        x.right = y.left;
        if (y.left !== null) y.left.parent = x;
        y.parent = x.parent;
        if (x.parent === null) this.root = y;
        else if (x === x.parent.left) x.parent.left = y;
        else x.parent.right = y;
        y.left = x;
        x.parent = y;
      }

      // Right rotation (similar to AVL tree rotation)
      rotateR(x) {
        let y = x.left;
        x.left = y.right;
        if (y.right !== null) y.right.parent = x;
        y.parent = x.parent;
        if (x.parent === null) this.root = y;
        else if (x === x.parent.right) x.parent.right = y;
        else x.parent.left = y;
        y.right = x;
        x.parent = y;
      }

      // Fixing the Red-Black Tree after insertion to maintain properties
      fix(z) {
        while (z.parent !== null && z.parent.color === "RED") {
          let g = z.parent.parent;
          if (z.parent === g.left) {
            let u = g.right;
            if (u !== null && u.color === "RED") {
              z.parent.color = "BLACK";
              u.color = "BLACK";
              g.color = "RED";
              z = g;
            } else {
              if (z === z.parent.right) {
                z = z.parent;
                this.rotateL(z);
              }
              z.parent.color = "BLACK";
              g.color = "RED";
              this.rotateR(g);
            }
          } else {
            let u = g.left;
            if (u !== null && u.color === "RED") {
              z.parent.color = "BLACK";
              u.color = "BLACK";
              g.color = "RED";
              z = g;
            } else {
              if (z === z.parent.left) {
                z = z.parent;
                this.rotateR(z);
              }
              z.parent.color = "BLACK";
              g.color = "RED";
              this.rotateL(g);
            }
          }
        }
        this.root.color = "BLACK";
      }

      // Insert a new node with the given data into the Red-Black Tree
      insert(data) {
        let z = new Node(data);
        let y = null;
        let x = this.root;

        // Traverse the tree to find the appropriate position for insertion
        while (x !== null) {
          y = x;
          if (z.data < x.data) x = x.left;
          else x = x.right;
        }

        // Assign the parent and insert the new node as a child
        z.parent = y;
        if (y === null) this.root = z;
        else if (z.data < y.data) y.left = z;
        else y.right = z;

        z.color = "RED";  // New nodes are always inserted as red
        this.fix(z);      // Fix the tree to maintain Red-Black properties
      }

      // In-order traversal to display the nodes in sorted order with their colors
      inorder(node, res) {
        if (node !== null) {
          this.inorder(node.left, res);  // Traverse the left subtree
          res.push(node.data + " (" + node.color + ")");  // Add the node's value and color
          this.inorder(node.right, res);  // Traverse the right subtree
        }
      }

      // Method to get the in-order traversal display of the Red-Black Tree
      display() {
        let res = [];
        this.inorder(this.root, res);
        return res.join(" ");
      }

      // Drawing a node and its connections recursively on the canvas
      drawNode(ctx, node, x, y, angle, depth, spread) {
        if (node) {
          const length = 50;  // Distance between parent and child nodes
          const childX = x + Math.cos(angle) * spread;  // Calculate X position of child node
          const childY = y + Math.sin(angle) * spread;  // Calculate Y position of child node

          // Draw the line between the current node and its child
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(childX, childY);
          ctx.stroke();

          // Draw the current node (circle)
          ctx.beginPath();
          ctx.arc(childX, childY, 20, 0, 2 * Math.PI);  // Draw circle with radius 20
          ctx.fillStyle = node.color === "RED" ? "#FF0000" : "#000000";  // Red or black based on the node's color
          ctx.fill();  // Fill the circle
          ctx.stroke();  // Outline the circle

          // Draw the node's value inside the circle
          ctx.fillStyle = "#FFFFFF";  // Set text color to white
          ctx.textAlign = "center";   // Align text in the center of the circle
          ctx.font = "14px Arial";    // Set the font for the node's value
          ctx.fillText(node.data, childX, childY + 5);  // Draw the node's data

          // Recursively draw the left and right children
          this.drawNode(ctx, node.left, childX, childY, angle - 0.5, depth + 1, spread * 0.8);
          this.drawNode(ctx, node.right, childX, childY, angle + 0.5, depth + 1, spread * 0.8);
        }
      }

      // Method to draw the entire Red-Black Tree on the canvas
      draw() {
        const canvas = document.getElementById("rbCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas before redrawing
        this.drawNode(ctx, this.root, canvas.width / 2, 50, Math.PI / 2, 0, 150);  // Start drawing from the root
      }
    }

    // Create an instance of the Red-Black Tree
    const tree = new Tree();

    // Function to handle adding a new node to the Red-Black Tree
    function addNode() {
      const val = parseInt(document.getElementById("val").value);  // Get the value from the input field
      if (!isNaN(val)) {
        tree.insert(val);  // Insert the value into the Red-Black Tree
        document.getElementById("out").textContent = "In-order: " + tree.display();  // Update the in-order traversal
        document.getElementById("val").value = "";  // Clear the input field
        tree.draw();  // Redraw the tree on the canvas
      }
    }
  </script>

</body>
</html>
